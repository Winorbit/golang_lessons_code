package main

import "fmt"

func main() {
/*Удалить последний элемент это все равно, 
что изменить значения среза
срез = срез[:длинна-1]
*/

// Удалить послений элемент
/*
var arr1 []int = []int{1,2,3,4}
fmt.Println(arr1)
arr1 = arr1[:len(arr1)-1]
fmt.Println(arr1)
*/

//Удалить первый элемент 
/*
var arr1 []int = []int{1,2,3,4}
fmt.Println(arr1)
arr1 = arr1[1:]
fmt.Println(arr1)
*/


/*Удалить кастомный элемент. Например - 3
План такой: Путем изменения СРЕЗОВ, манипуляции с содержанием, 
мы сдвигаем кусочек большого среза так, чтоб ненужный элемент был убран, 
а, для сохранения длинны, предпоследний элемент дублирует послений.
*/
var arr1 []int = []int{1,2,3,4,5,6,7}
fmt.Println(arr1)
copy(arr1[3:], arr1[4:])
fmt.Println(arr1)
arr1 = arr1[:len(arr1)-1]
fmt.Println(arr1)


// Что тут происходит?
/*
copy(arr1[3:], arr1[4:])

Мы берем два среза:
Перый - от элемента, который хоти удалить и до конца:
arr1[3:]  - [4 5 6 7]
Второй - от элемента на удаление + 1 - 
arr1[4:] - [5 6 7]

Использование copy
copy(arr1[3:], arr1[4:])

приводит к тому, что 

[5 6 7] 
по порядку заменяеет элементы в 
[4 5 6 7]

5			6 		  7
заменяет заменяет  заменяет    остаеться на месте
4 			5		  6 			7

В результате выходит 
[1 2 3 5 6 7 7]

А затем мы просто удаляем лишнюю 7
arr1 = arr1[:len(arr1)-1]
*/

// Удалить, не сохраняя порядок
a := []string{"A", "B", "C", "D", "E"}
i := 2

// Удалить элемент по индексу i из a.

// 1. Копировать последний элемент в индекс i.
a[i] = a[len(a)-1] 

// 2. Удалить последний элемент (записать нулевое значение).
a[len(a)-1] = ""  

// 3. Усечь срез.
a = a[:len(a)-1]  

fmt.Println(a) // [A B E D]

}
